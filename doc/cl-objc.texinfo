\input texinfo
@setfilename cl-objc
@settitle cl-objc

@c Some plain TeX macrology to wrap text in \hbox{} only if the text
@c contains no hyphens.
@iftex
@tex
\newif\ifdash
\long\def\dashp#1{\expandafter\setnext#1-\dashphelper}
\long\def\setnext#1-{\futurelet\next\dashphelper}
\long\def\dashphelper#1\dashphelper{
  \ifx\dashphelper\next\dashfalse\else\dashtrue\fi
}
\def\lw#1{\leavevmode\dashp{#1}\ifdash#1\else\hbox{#1}\fi}
@end tex
@end iftex

@c A Texinfo binding for the plain TeX above.  Analogous to Texinfo's
@c @w, but for Lisp symbols.  AFAICT, the comment characters are
@c necessary to prevent treating the newline as a space.
@macro lw{word}
@iftex
@tex
\\lw{\word\}%
@end tex
@end iftex
@ifnottex
\word\@c
@end ifnottex
@end macro

@copying
Documentation for the Common Lisp ObjC Interface, version 1.0.

Copyright @copyright{} 2007 Geoff Cant, Luigi Panzeri

@quotation
Copying and distribution of this file, with or without modification, are
permitted in any medium without royalty provided the copyright notice
and this notice are preserved.
@end quotation
@end copying

@titlepage
@title Common Lisp ObjC Interface

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Common Lisp ObjC Interface Library
 
@insertcopying
@end ifnottex

@menu 
* Introduction::    What is CL-ObjC?
* Tutorial::        Brief Guide to CL-ObjC
* CFFI Bindings::   Using simple wrappers of ObjC FFI
* Lisp Interface::   Writing ObjC application using Common Lisp wrappers
* CLOS Wrappers::   The CLOS wrapper to ObjC object system
* Reader Macro::    Using the reader macro to write in ObjC style
* Implementation Notes::
* Index::           Complete index.
@end menu

@node Introduction
@chapter Introduction

@section What is CL-ObjC?
CL-ObjC is a Common Lisp library whose aims are to allow developers to
use libraries written in the Objective C language, providing a lisp-like
interface towards Objective C conventions.

Actually it is made of 3 different interfaces. 

The first one provided by the package @lw{OBJC-CFFI} expose the CFFI
bindings to the users but allowing them to manage ObjC data through
Common Lisp classes via the CFFI foreign type translators mechanism.

The second one, you can find in the OBJC-READER package, provides a
reader macro that allows user to mix ObjectiveC and Common Lisp syntax,
but it doesn't support creation of ObjC classes and methods at runtime.

The last one provided by the package @lw{CL-OBJC} gives to the users the
ability to write application in a more Common Lisp-like way.

This manual is a work in progress. If you have difficulty using or
comprehending it please contact @email{cl-objc-devel@@common-lisp.net,
the developers} with details.

@section Status
At the moment CL-ObjC has been tested mainly on x86/64 platform on
Darwin. As CL-ObjC uses CFFI to link with the Objective C runtime
foreign functions, it should not be a problem to use it portably on
other platforms or OSs.

@section Download and installation
You can get the current development version of CL-ObjC from the darcs
repository on @uref{http://common-lisp.net/project/cl-objc/darcs/cl-objc/}

Experimental versions can be also found on
@uref{http://www.innerloop.it/~matley/cl-objc-soc}

@section Installation 
CL-ObjC is packaged using the ASDF library, so once downloaded the code
you should change the asdf:*central-registry* parameter to make asdf
find the cl-objc.asd file, or you can make a symbolic link of it in a
directory already in asdf:*central-registry*.

To build CL-ObjC you need to get a recent (at least from February 2007)
version of CFFI. You can get the development version from the darcs
repository at @uref{http://common-lisp.net/project/cffi/darcs/cffi/}.

In order to work CL-ObjC needs to find the libobjc library. By default
it will search for it in /usr/lib. Change *foreign-library-directories*
if you want to load libobjc from a different path.

To run tests bundled with CL-ObjC you need the FiveAM test unit
software, then you can eval:

@lisp
(asdf:oos 'asdf:load-op 'cl-objc)
(asdf:oos 'asdf:test-op 'cl-objc)
@end lisp

@section Authors 
@enumerate
* @email{nem@@lisp.geek.nz,Geoff Cant}: initial author
* @email{matley@@muppetslab.org, Luigi Panzeri}: main developer
@end enumerate

@section Acknowledgments
Thanks to the @uref{http://www.lispnyc.org,LispNyC} (that approved and
voted this project) this project was funded by Google Inc. in the Summer
of Code of 2007. We thanks also @email{mb@@bese.it, Marco Baringer}
mentor of the project during the SoC.
Parts of this manual have be generated by the SB-TEXINFO software.

@node Tutorial
@chapter Tutorial

@section Quick start
The purpose of CL-ObjC is to allow to use Objective C with Lisp-like
syntax. Actually we can do that with three equivalent way. For the
impatient an ObjC call like:

@verbatim
[my_obj doSomethingCoolAt: now withThisParam 5]
@end verbatim

can be equivalently be executed in CL-ObjC

@itemize
* using the low level facility in the package OBJC-CFFI :
  @lisp
  (typed-objc-msg-send (my-obj ``doSomethingCoolAt:withThisParam'') 'objc-id now :int 5)
  or
  (untyped-objc-msg-send (my-obj ``doSomethingCoolAt:withThisParam'') now 5)
  @end lisp

* using the reader macro in the package OBJC-READER :
  @lisp
  [,my-obj doSomethingCoolAt: now withThisParams 5]
  @end lisp

* using the interface provided by the package CL-OBJC :
  @lisp
  (invoke my-obj :do-something-cool-at now :with-this-param 5)
  @end lisp
@end itemize

So every message call can be specified in a typed or untyped way, i.e.
expliciting the CFFI type of the arguments or not, or mixing the two
approach. Actually if types are available the compiler can optimize at compile
time the message call.

@section Loading Frameworks
Once loaded CL-Objc we can use existing Objective C classes and methods
loading frameworks with the macro DEFINE-OBJC-FRAMEWORK:

@example
(define-objc-framework "Foundation"
  (define-objc-struct ns-range 
    (location :unsigned-int) 
    (length :unsigned-int)))
@end example

The call takes a bit of time to collect just at compile time
informations about data types. In the body of this macro you can
optionally include custom CFFI definitions, usually useful to define
better names for structs and fields.

@section Type translations

Objective C types are translated directly into Common Lisp types. Common
C types (float, int, char *) are translated by CFFI in the common way.
Struct values as in CFFI are always managed by a pointer to their data.
The specific Objective C types (like id) are translated automatically by
foreign type translators into lisp types and viceversa when needed.
Several CLOS classes are added to handle them. The following types
translators are installed:

@multitable @columnfractions .33 .33 .33
@item @emph{Objective C type} @tab @emph{Description} @tab @emph{Lisp type}
@item SEL @tab selectors @tab objc-selector
@item objc_class @tab Class description @tab objc-class
@item id @tab Instance Object @tab objc-object
@item objc_method @tab Method Object @tab objc-method
@item objc_method_list @tab List of Methods @tab a list o objc-method
@item objc_ivar @tab Instance variable @tab objc-ivar
@item objc_ivar_list @tab Instance variable lists @tab objc-ivar-list
@end multitable

You can also use normal string to specify classes or selectors in the
OBJC-CFFI package and they will be translated to the type needed.

@section Name translators
In the CL-OBJC package you don't specify class and selector by strings
but with symbols. To see how a given ObjC or Lisp name will be
translated by the bridge, you can use the following functions:

@lisp
(objc-class-name-to-symbol string)
(symbol-to-objc-class-name symbol)
(objc-selector-to-symbols string)
(symbols-to-objc-selector symbol-list-or-symbol)
@end lisp

So for example the class ``NSObject'' is translated to ns-object, the
class ``VeryImportant'' to very-important and so on. You can add strings
to the special variable @var{*acronyms*} in order to not espand acronyms
like URL into u-r-l.

A selector name is translated in a list of symbols or a single symbol. 

@example
@table @code
@item [NSObject alloc]
(invoke 'ns-object alloc)
@item [obj setX: 3 Y: 5]
(invoke obj :set-x 3 :y 5)
@item [NSNumber numberWithInt: 3]
(invoke 'ns-number :number-with-int 3)
@end table
@end example

@section The Currency Converter Example
This section concerns the construction of a Cocoa application using an
UI built with XCode. You can find the instructions to use the Interface
Builder tool to build the interface used in the example at
@url{http://developer.apple.com/documentation/Cocoa/Conceptual/ObjCTutorial/}.

A Cocoa application is usally deployed as a bundle. A bundle is just a
directory containing all the resourcs (images, sounds, data) the
application needs. Interface Builder saves descriptions of UI in
serialized objects saved in file in the NIB file format stored in the
bundles.

If you follow the instructions of the quoted Cocoa tutorial you will
find in the directory project your bundle, namingly a folder with the
.app extension.

In order to have a Cocoa application using NIB files and integrated with
OSX you have to put a link (symbolic or not) to sbcl and a script
launching your Cocoa lisp application into the MacOS subfolder of your
bundle. Usually the script execute sbcl to load and launch your code.

Note that in that script you can create a swank server you can attach to
allowing live debugging of your application@footnote{You can find an
example of this script in the cl-objc bundle}.

Let's load the frameworks used in our applications:

@table @strong
@item Objective C code
Lisp code
@item #import ``Foundation/foundation.h''
(define-objc-framework ``Foundation'')
@item #import ``AppKit/AppKit.h''
(define-objc-framework ``AppKit''
   (cffi:defcvar "NSApp" objc-id))
@item #import ``Cocoa/Cocoa.h''
(define-objc-framework ``Cocoa'')
@end table

The CFFI:defcvar binds the variable *nsapp* to a static variabile used
by the Cocoa framework.

Then we can define the class definitions for the model and for the
controller of the GUI using the DEFINE-OBJC-CLASS macro found in the
CL-OBJC package.
@lisp
(define-objc-class converter ns-object
  ())

(define-objc-class converter-controller ns-object
  ((converter objc-id)
   (first-currency-field objc-id)
   (other-currency-field objc-id)
   (rate-field objc-id)))
@end lisp

The DEFINE-OBJC-CLASS macro gets three arguments, the name of the class
and of the superclass transformed with the name translators cited
before, and the a list of instance variable definitions.

So the @var{converter-controller} class will be added to the Objective C
runtime class list with the name ``ConverterController'' and defines 4
instance variables with ObjC names: ``converter'',
``firstCurrencyField'', ``otherCurrencyField'', ``rateField''.

Then we can define the methods with the CL-OBJC:DEFINE-OBJC-METHOD
macro:

@example
@lisp
(define-objc-method :convert (:return-type :void)
    ((self converter-controller) (sender objc-id))
  (declare (ignore sender))
  (with-ivar-accessors converter-controller
    (let* ((currency (invoke (first-currency-field self) float-value))
	   (rate (invoke (rate-field self) float-value))
	   (amount (invoke (converter self) :convert-currency currency :at-rate rate)))
      (invoke (other-currency-field self) :set-float-value amount)
      (invoke (rate-field self) :select-text self))))

(define-objc-method (:convert-currency :at-rate) (:return-type :float)
    ((self converter) (currency :float) (rate :float))
  (* currency rate))
@end lisp
@end example

This macro gets 3 arguments plus the body of the method. The name of the
related selector specified with a symbol or a list of symbols, a list of
option and a list of argument definition made of the argument name and
its CFFI type. The argument named @emph{self} is mandatory and will
binded to the receiver of the message. The body will be evaluated also
with the symbol @emph{sel} binded to the selector object of the method.

So the second definition in the example define the instance method named
``convertCurrency:atRate:'' returning a :float. It accepts 2 arguments
and it is binded to the class converter.

At last the main entry point of our application looks like:

@lisp
(defun converter ()
  (invoke 'ns-application shared-application)
  (invoke 'ns-bundle :load-nib-named (lisp-string-to-nsstring "MainMenu") :owner *nsapp*)
  (invoke *nsapp* run))
@end lisp

If we activate the reader macro we can specify NSString object using the
at-sign so (lisp-string-to-nsstring ``MainMenu'') becomes @@"MainMenu''

@node CFFI Bindings
@chapter CFFI Bindings

@section API Reference

@subsection Frameworks
@include include/macro-objc-cffi-define-objc-framework.texinfo

@subsection Structs
@include include/fun-objc-cffi-objc-struct-slot-value.texinfo
@include include/macro-objc-cffi-define-objc-struct.texinfo
@include include/fun-objc-cffi-symbol-to-objc-class-name.texinfo
@include include/fun-objc-cffi-objc-class-name-to-symbol.texinfo

@subsection Classes
@include include/fun-objc-cffi-get-class-list.texinfo
@include include/fun-objc-cffi-objc-get-class.texinfo
@include include/fun-objc-cffi-get-class-methods.texinfo
@include include/fun-objc-cffi-get-instance-methods.texinfo
@include include/fun-objc-cffi-class-get-class-method.texinfo
@include include/fun-objc-cffi-class-get-instance-method.texinfo
@include include/fun-objc-cffi-class-has-public-ivars.texinfo
@include include/fun-objc-cffi-super-classes.texinfo
@include include/var-objc-cffi-objc-nil-class.texinfo

@subsection Instance Variables
@include include/fun-objc-cffi-make-ivar.texinfo
@include include/fun-objc-cffi-private-ivar-p.texinfo

@subsection Defining methods and classes at runtime
@include include/fun-objc-cffi-add-objc-class.texinfo
@include include/fun-objc-cffi-ensure-objc-class.texinfo
@include include/macro-objc-cffi-add-objc-method.texinfo

@subsection Instanced Objects
@include include/fun-objc-cffi-objc-nil-object-p.texinfo
@include include/fun-objc-cffi-set-ivar.texinfo
@include include/fun-objc-cffi-get-ivar.texinfo
@include include/var-objc-cffi-objc-nil-object.texinfo
@include include/class-objc-cffi-objc-object.texinfo

@subsection Selectors
@include include/fun-objc-cffi-sel-get-uid.texinfo

@subsection Message Sending
@include include/macro-objc-cffi-untyped-objc-msg-send.texinfo
@include include/macro-objc-cffi-typed-objc-msg-send.texinfo

@subsection Type Parsing
@include include/var-objc-types-typemap.texinfo
@include include/fun-objc-types-parse-objc-typestr.texinfo
@include include/fun-objc-types-encode-types.texinfo
@include include/fun-objc-types-encode-type.texinfo

FIXME: exported accessors need documentation too!

@node Lisp Interface
@chapter Lisp Interface

@section API Reference

@subsection Name Translators
@include include/fun-cl-objc-symbols-to-objc-selector.texinfo
@include include/fun-cl-objc-objc-selector-to-symbols.texinfo
@include include/var-cl-objc-star-acronyms-star.texinfo

@subsection Macrology
@include include/macro-cl-objc-with-object.texinfo
@include include/macro-cl-objc-with-ivar-accessors.texinfo
@include include/macro-cl-objc-slet.texinfo
@include include/macro-cl-objc-slet-star.texinfo
@include include/macro-cl-objc-objc-let.texinfo

@subsection Message Calling
@include include/macro-cl-objc-invoke.texinfo
@include include/fun-cl-objc-selector.texinfo

@subsection Defining method and classes at Runtime
@include include/macro-cl-objc-define-objc-method.texinfo
@include include/macro-cl-objc-define-objc-class.texinfo

@node Reader Macro
@chapter Reader Macro

@include include/var-objc-reader-star-accept-untyped-call-star.texinfo
@include include/fun-objc-reader-restore-readtable.texinfo
@include include/fun-objc-reader-activate-objc-reader-macro.texinfo

@node CLOS Wrappers
@chapter CLOS Wrappers
To be implemented

@node Implementation Notes
@chapter Implementation Notes

@section Limits
@enumerate
@include ../KNOWN_BUGS.txt
@end enumerate

@node Index
@unnumbered Index
@printindex cp
@bye
